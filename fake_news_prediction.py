# -*- coding: utf-8 -*-
"""Fake News Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15tsRIVoyqb1ZhnorcFxWlQy-EeFnBVNH

About the Dataset:

1. id: unique id for a news article
2. title: the title of a news article
3. author: author of the news article
4. text: the text of the article; could be incomplete
5. label: a label that marks whether the news article is real or fake:
           1: Fake news
           0: real News

Importing dependencies
"""

import numpy as np
import pandas as pd
import re
import pickle
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

import nltk
nltk.download('stopwords')

print(stopwords.words('english'))

data = pd.read_csv('/content/train.csv (2).zip')

data.shape

data.head()

data.tail()

data.isnull().sum()

# replacing the null values with empty strings
data=data.fillna('')

# merging the author name and news title
data['content'] = data['author'] + ' ' + data['title']

print(data['content'])

# seperating the data and label
X = data['content']
Y = data['label']

print(X)

print(Y)

data['label'].value_counts()

data.describe()

port_stem = PorterStemmer()

def stemming(content):
  # removing all non - alphabeticl characters and converting to lowercase
  stemmed_content = re.sub('[^a-zA-Z]',' ',content).lower()
  # splitting the content into words
  stemmed_content = stemmed_content.split()
  # stemming each word and removing stopwards
  stemmed_content = [port_stem.stem(word) for word in stemmed_content if not word in stopwords.words('english')]
  # joining words back into a single string
  stemmed_content = ' '.join(stemmed_content)
  return stemmed_content

X = X.apply(stemming)

print(X)

X=data['content'].values
Y=data['label'].values

print(X)

print(Y)

Y.shape

# converting the textual data into numerical data
vectorizer = TfidfVectorizer()
vectorizer.fit(X)
X=vectorizer.transform(X)

print(X)

X_train , X_test , Y_train , Y_test = train_test_split(X,Y,test_size=0.2, stratify=Y , random_state=2)

model = LogisticRegression()

# tains the model using training data
model.fit(X_train , Y_train)

# Save the trained model and vectorizer
with open('trained_model.sav', 'wb') as model_file:
    pickle.dump(model, model_file)

with open('tfidf_vectorizer.pkl', 'wb') as vectorizer_file:
    pickle.dump(vectorizer, vectorizer_file)

X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction , Y_train)

print('Accuracy score of the traing data : ' , training_data_accuracy)

X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction , Y_test)

print('Accuracy score of the test data : ' , test_data_accuracy)

X_new = X_test[3]

prediction = model.predict(X_new)
print(prediction)

if(prediction[0]==0):
  print('The news is Real')
else:
  print('The news is Fake')

print(Y_test[3])

"""Confusion Matrix"""

from sklearn.metrics import confusion_matrix , ConfusionMatrixDisplay
import matplotlib.pyplot as plt

# predictions on test set
Y_pred = model.predict(X_test)
cm = confusion_matrix(Y_test , Y_pred , labels=[0,1])
print("Confusion Matrix")
print(cm)

# visualize the confusion matrix
disp = ConfusionMatrixDisplay(confusion_matrix = cm , display_labels = ['Fake' ,'Real'])
disp.plot(cmap = plt.cm.Blues)
plt.show()

TP = cm[1 , 1]
FN = cm[1 , 0]
FP = cm[0 , 1]
TN = cm[0 , 0]

precision =  TP/ (TP + FP)
print(precision)

recall= TP / (TP + FN)
print(recall)

f1_scoree = 2 * (precision * recall) / (precision + recall)
print(f1_scoree)

from sklearn.metrics import precision_score, recall_score, f1_score

precision = precision_score(Y_test , Y_pred , pos_label=1)
print(precision)

recall = recall_score(Y_test , Y_pred , pos_label=1)
print(recall)

from sklearn.metrics import classification_report

Y_pred = model.predict(X_test)
report = classification_report(Y_test, Y_pred)
print(report)

